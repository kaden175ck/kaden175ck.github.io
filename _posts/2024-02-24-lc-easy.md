---
layout: post
title: "LeetCode Easy"
date: 2024-02-25
categories: leetcode
---

I've always struggled with LeetCode problems, so I've set a goal to tackle one LeetCode problem every day. These will be from the easy section. I'll keep updating my posts with my progress. The day I don't need to post anymore will be the day I can breeze through lc-problems with no trouble.

---
<br>
<br>
<br>
**Problem1: Two Sum**

Given an array of integers (`nums`) and an integer (`target`), return the indices of the two numbers that add up to the `target`.

**Example:**

```
nums = [2, 7, 11, 15]
target = 9
Output: [0, 1]  // Because 2 + 7 = 9
```

**Constraints**

* You may assume that each input would have exactly one solution.
* You may not use the same element twice.

**My thoughts**

* 1: Brute force it, for i in num, we use i+(i+1) to match the target, if unmatch then move on to check i+1+(i+1+1)...until target match.
* 2: loop the array, then target - num = complement, we check if complment is seen in the dictionary, if seen we get the current array index and the index of the seen dictionary. As we loop through the array, we store each number as a key in the hashmap and its index as the value.For each number, we calculate the complement needed to reach the target. Then we simply check if that complement already exists as a key in our hashmap. If it does, we've found our pair!

**Smart way**

Python:
def two_sum(nums, target):
    seen = {}  # Create an empty hashmap (dictionary)

    for index, num in enumerate(nums):  # enumerates assgin pairs, turns your nums list into pairs 
    # like this:(0, 2)  index 0, value 2 ; (1, 7) index 1, value 7
                                                 
        complement = target - num
        if complement in seen:  # The complement is found...
            return [seen[complement], index]  //get the 2 index
            //If the complement is already present as a key(key in hashmap is like words, like real stuff, in this case is the number itself) in the seen hashmap, it means its found. Return the index of the current number(index) and the stored index(stored value in hashmap seen[complement]). remember the stored value its the index

        seen[num] = index  # store the current num as a key and its index as the value in our seen dictionary

    return None  # This means no solution was found

why this work:
By storing numbers as keys, we can quickly check if the complement we need has already been seen during our loop.

**Brute Froce Way**

def two_sum_brute_force(nums, target):
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):  # Start inner loop from next index
            if nums[i] + nums[j] == target:
                return [i, j]

    return None  # No solution found

**Space Complexity**

Brute Force Time Complexity: O(n^2). We have nested loops, each going through potentially all elements.

Hashmap Approach Time Complexity: O(n). On average, we loop through the array once, and hashmap operations are fast.


---
<br>
<br>
<br>
**Problem2: Palindrome Number**

Determine if an integer is a palindrome, where it reads the same backward as forward.

**Example:**

* Input: 121  
  Output: true

* Input: -121 
  Output: false (negative numbers are not palindromes)

* Input: 10
  Output: false

**Constraints**

You shouldn't convert the integer into a string to solve this problem. Think about how you can work with the number itself mathematically.


**My thoughts**
Using % rio get the last digit , and division // by 10 to shift the digt, build a rever one and compare it with the original

**Python Smart Solution**
def is_palindrome(x):
    if x < 0:
        return False

    original_num = x  # original number x
    reversed_num = 0  # Initialize the reversed number 
    // extract digits and build reversed_num
    while x > 0:  # Loop as long as the number is positive
        last_digit = x % 10  # Extract the last digit
        reversed_num = reversed_num * 10 + last_digit // shhifting the previous number to the left(*10)
        x = x // 10  # Remove the last digit from the original number 

    # Handle potential middle digit in reversed_num
    if original_num // 10 == reversed_num // 10:  //removes the middle digit if the original has odd len
        return True
    else:
        return False

**Python no Opt Solution**
previous solustion include an optimization where we only need to reverse about half of the digits to determine if a number is a palindrome.
Reseaon why Opt works: 
Odd number of digits: The middle digit doesn't affect if it's a palindrome (e.g., in '12321', the '3' doesn't matter).
Even number of digits: All digits must fully match when reversed.


// not Opt veriosn
fully reversed number first and then compare it to the original:
def is_palindrome(x):
    if x < 0:
        return False

    original_num = x
    reversed_num = 0

    while x > 0: 
        last_digit = x % 10
        reversed_num = reversed_num * 10 + last_digit
        x = x // 10    // its same as Opt version untill here
        //The loop continues until the entire number is reversed.

    # Comparison after building the complete reversed number
    return original_num == reversed_num  



---
<br>
<br>
<br>

**Problem3: Roman to Integer**

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

|Symbol| Value|
|---|---|
|I|1|
|V|5|
|X|10|
|L|50|
|C|100|
|D|500|
|M|1000|

They are usually written largest to smallest from left to right. However, the numeral for four is not IIII, but rather IV. The six subtractive combinations are:

* IV (5 - 1 = 4)
* IX (10 - 1 = 9)
* XL (50 - 10 = 40)
* XC (100 - 10 = 90)
* CD (500 - 100 = 400)
* CM (1000 - 100 = 900)

Given a roman numeral, convert it to an integer.

**Example**

* Input: "III"
  Output: 3

* Input: "LVIII"
  Output: 58 (L = 50, V= 5, III = 3)

* Input: "MCMXCIV"
  Output: 1994 (M = 1000, CM = 900, XC = 90 and IV = 4)

**Hint**
* Think about using a dictionary (hashmap) to store the mappings between the Roman numeral symbols and their corresponding integer values. 
* Process the Roman numeral string from left to right. 
* If the current symbol's value is greater than or equal to the value of the previous symbol, you simply add its value to your running total.
* However, if the current symbol's value is less than the previous symbol's value, it means you have one of the subtractive cases (like 'IV' or 'IX').  
* Instead of checking for every possible subtractive case individually, we store the valid subtractive pairs in a list or a set. subtractive_pairs = ["IV", "IX", "XL", "XC", "CD", "CM"]


**Specific Example:**  In the Roman numeral  "MCMXCIV":

* M (1000) -> Add to the total
* CM (900) -> Since 'C' is smaller than 'M', subtract this from the total
* XC (90) -> Likewise, subtract 
* IV (4) -> Subtract


**Python Solution**
```python
def roman_to_integer(s):
    symbol_values = {  # Create dictionary of Roman symbol values
        "I": 1,
        "V": 5,
        "X": 10,
        "L": 50,
        "C": 100,
        "D": 500,
        "M": 1000
    }
    subtractive_pairs = ["IV", "IX", "XL", "XC", "CD", "CM"]
    # Instead of checking for every possible subtractive case individually, we store the valid subtractive pairs in a list or a set, so that we could just compare it

    total = 0  # Count for total value
    i = 0
    while i < len(s):  # Loop through the Roman numeral string

        if i + 1 < len(s):
            next_symbol = s[i + 1]
        else:
            next_symbol = ""  # At the last symbol, so set to empty string

        two_symbols = s[i] + next_symbol # like MD
        # Combine the current and next symbols into a string

        if two_symbols in subtractive_pairs:
            total += symbol_values[next_symbol] - symbol_values[s[i]]  # Subtract value of the first symbol from the second
            i += 2  # Move ahead two positions
        else:
            total += symbol_values[s[i]]  # Add value of the single symbol
            i += 1  # Move ahead one position

    return total

```





---
<br>
<br>
<br>
**Problem:  Fizz Buzz**

Write a program that prints the numbers from 1 to 100. But for multiples of three, print "Fizz" instead of the number, and for the multiples of five, print "Buzz". For numbers which are multiples of both three and five, print "FizzBuzz".

**Example:**

```
Output:
1
2
Fizz
4
Buzz
Fizz
...
```

**Considerations**
* `15 % 3 == 0`  // 15 is divisible by 3
*  `12 % 5 == 0` // 12 is divisible by 5

* **Check for both 3 and 5:** If the number is divisible by both 3 and 5, print "FizzBuzz".
* **Check for 3:** If the number is divisible by 3, print "Fizz".
* **Check for 5:** If the number is divisible by 5, print "Buzz".
* **Default:** If none of the above conditions are true, print the number itself.

**Python Solution**

```python
def fizz_buzz():
    for num in range(1, 101):  # Loop through the numbers
        if num % 3 == 0 and num % 5 == 0:  # Check divisibility by 3 and 5
            print("FizzBuzz")
        elif num % 3 == 0:                 # Check divisibility by 3
            print("Fizz")
        elif num % 5 == 0:                 # Check divisibility by 5
            print("Buzz")
        else:                              # Not divisible by 3 or 5
            print(num)
```
**Important Note:** The order of the `if` and `elif` conditions matters! You have to check for "FizzBuzz" (divisible by both 3 and 5) first. 




---
<br>
<br>
<br>

**Problem: Contains Duplicate:**

Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**

* Input: nums = [1,2,3,1]
* Output: true (1 appears twice)

**Example 2:**

* Input: nums = [1,2,3,4]
* Output: false (all elements are unique)

**Example 3:** 

* Input: nums = [1,1,1,3,3,4,3,2,4,2]
* Output: true (many duplicates!)

**Hint:** Consider using a hashmap (dictionary) to keep track of the numbers you've seen so far.

**Python Solution**
'''python

def contains_duplicate(nums):
    seen = set()
    for  num in nums
        if num in seen
            return True
        else
            seen.add(num)
    return False
        
'''

---
<br>
<br>
<br>


**Problem:  Two Sum II - Input Array Is Sorted**

Given a **sorted** array of integers (`nums`) and a target value, find the indices of the two numbers that add up to the target. You can assume there's exactly one solution, and you cannot use the same element twice.

**Note:** The array is 1-indexed, meaning the first element has an index of 1.

**Example 1:**

* Input: nums = [2, 7, 11, 15], target = 9
* Output: [1, 2] (Because 2 + 7 = 9)

**Example 2:**

* Input: nums = [2, 3, 4], target = 6
* Output: [1, 3]  (Because 2 + 4 = 6)


**Considerations**

* **Sorted Array (Important):** The fact that the array is sorted gives us a potential advantage. Think about how you might take advantage of that.
* **Hashmaps:** Can a hashmap still be helpful in this scenario?


**Python Solution**
def two_sum_sorted(nums, target):
    seen={}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement]+1, i+1]
        seen[num]=i
    return None 


---
<br>
<br>
<br>


**Problem: Best Time to Buy and Sell Stock**

You are given an array `prices` where `prices[i]` is the price of a given stock on the `i`th day.  You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.

**Example 1:**

* Input: prices = [7,1,5,3,6,4]
* Output: 5 
  * Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.

**Example 2:**

* Input: prices = [7,6,4,3,1]
* Output: 0
  * Explanation: In this case, no transaction is done, i.e. max profit = 0.

**Considerations:**

* Think about how you would track the minimum price seen so far.
* How can you continuously update your potential maximum profit?


